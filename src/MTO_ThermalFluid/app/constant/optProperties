/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  5                                     |
|   \\  /    A nd           | Web:      www.OpenFOAM.org                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    location    "constant";
    object      optProperties;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

// ========================================================================== //
// 1. DESIGN REGION                                                           //
// ========================================================================== //
fluid_area          yes;       // Keep fluid-designated zone fixed as fluid
solid_area          no;        // Keep solid-designated zone fixed as solid
test_area           no;        // Enable test-zone initialization override

// ========================================================================== //
// 2. OBJECTIVE & CONSTRAINTS                                                 //
// ========================================================================== //
objFunction         1;         // 1: mean temperature, 2: p-norm max temperature
PowerDiss0          1e-8;      // Reference dissipation for normalization
PowerDissMax        10;        // Max allowed power dissipation constraint
PowerDissRelax      25;        // Dissipation constraint relaxation window
voluse              0.4;       // Target volume fraction
GeoDim              2;         // Geometric dimension (affects filter length scale)
Pnorm               300;       // p-norm exponent for max-temperature approximation (objFunction=2)

// ========================================================================== //
// 3. MMA OPTIMIZER                                                           //
// ========================================================================== //
filterR             2.5;       // Filter radius (smaller = less smoothing, less gray; 2-3 cell radii typical)
raa0                1e-5;      // MMA regularization parameter
mma_init            0.3;       // MMA asymptote initialization factor
mma_dec             0.7;       // MMA asymptote decrease factor
mma_inc             1.2;       // MMA asymptote increase factor
movlim              0.4;       // MMA move limit (larger = faster updates; 0.2 for gray suppression)

// ========================================================================== //
// 4. LEGACY FILTER (with turbulence extension)                               //
// ========================================================================== //
// Length scale (used by both cascaded and legacy)
filterLenAniso      yes;       // yes = geometric-mean len for channel mesh; no = volume-based
filterTurbReScale   no;        // yes = scale filterR by (Re_ref/Re)^0.5 for high-Re (legacy path)
Re_ref              8000;      // Reference Re for filter scaling (U=1 m/s, Dh=8 mm, nu=1e-6)
heavisideGraySuppression  legacy;	// Heaviside projection (legacy filter; cascaded uses same for its Heaviside stage)
// legacy|low|medium|high|strong; legacy=parent MTO new_2022.12.15 (del=min(0.2*opt,100)); override with heavisideDelFactor/Cap/Start/Init if needed

// ========================================================================== //
// 5. CASCADED FILTER                                                         //
// ========================================================================== //
useCascadedFilter   no;        // yes = cascaded (stage1 + stage2); no = legacy single-stage
filterR2            1.35;      // Stage 2 radius (tighter = less gray; was 1.6)
filterStage2Nonlinear no;      // yes = fW-mean power stage (gray suppression); no = linear PDE (more gray)
filterPMean         8;         // fW-mean exponent p (higher = sharper, less gray; 8–12 for strong suppression)

// ========================================================================== //
// 6. BRINKMAN & DENSITY PROJECTION                                           //
// ========================================================================== //
useDesignBoundaryBlend no;     // Blend design cells adj to fluid toward xh=1 (yes = less gray at boundaries)
quInit              0.008;     // Initial qu (larger = less stiff; was 0.005)
quRampStart         100;       // Iteration to start qu ramp (was 80)
quRampRate          8e-5;      // qu increment per opt (slower than 1e-4)
quCap               0.012;     // qu cap (was 0.01)
xhFloorTurbMult     1.5;       // Multiplier on xh floor for turbulent (1=laminar; 1.5=turbulent)
designBoundaryBlend 0.12;      // Blend strength when useDesignBoundaryBlend yes (0–1; stronger = less gray)

// ========================================================================== //
// 7. ADJOINT: COUPLING                                                       //
// ========================================================================== //
nAdjTurbPasses      2;         // Number of adjoint turbulence coupling passes per opt step
turbSensDamp        0;         // Sensitivity damping for turbulence source contribution

// ========================================================================== //
// 8. RUNTIME DIAGNOSTICS (adjoint sections 8-10 pruned; see docs/ADJOINT_OPTIONS_FOR_CONVERGENCE.md)
// ========================================================================== //
writeMeshFilterHeader yes;     // Write mesh/filter estimates to solver_status.log at opt 1
diagLevel           0;         // 0: off, 1: metrics, 2: full field-health logs
diagEvery           1;         // Log diagnostics every N optimization iterations
diagRank            -1;        // -1: all ranks, otherwise selected MPI rank only
diagOptStart        120;       // First optimization iteration to begin diagnostics

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
